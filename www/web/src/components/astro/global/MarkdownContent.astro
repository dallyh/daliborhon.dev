---
import { m } from "@paraglide/messages";
import { generateTOCHTML } from "@utils/content";
import type { MarkdownHeading } from "astro";

interface Props {
	tocPosition?: "inside" | "default";
	headings?: MarkdownHeading[];
}

const { tocPosition = "default", headings } = Astro.props;
---

<article class=`md-content prose max-w-none ${tocPosition}` id="article">
	{
		headings && headings.length !== 0 && (
			<div id="toc" class="bg-base-200 rounded-xl border border-slate-300/5">
				<details id="tocDetails" class="max-[1024px]:collapse-arrow collapse">
					<summary class="collapse-title text-xl">{m.blog__toc()}</summary>
					<nav class="toc">
						<Fragment set:html={generateTOCHTML(headings)} />
					</nav>
				</details>
			</div>
		)
	}
	<div id="content">
		<slot />
	</div>
</article>

<script is:inline>
	//import "https://unpkg.com/intersection-observer-debugger";
	// Itentionally inlined to prevent FOUC
	function openToc() {
		const details = document.querySelector("#tocDetails");
		if (!details) return;

		const width = window.innerWidth;
		details.open = width >= 1024;
	}

	openToc();
	window.addEventListener("resize", openToc);

	window.addEventListener("DOMContentLoaded", () => {
		const $toc = document.querySelector(".toc > ul");
		// Our functionality revolves around this selector, it has the built in assumptions mentioned above
		const $anchorLinks = $toc.querySelectorAll('a[href^="#"]');

		// tocMap is our data and state
		// Structure is:
		// [sectionId] = {
		//   'link': {HTMLElement} <Reference to ToC Link element>,
		//   'section': {HTMLElement} <Reference to element toc Link is pointed at>,
		//   'isIntersecting': {boolean} <Whether or not the element is visible/intersecting>
		// }
		const tocMap = {};

		/**
		 * Highlight a section in the ToC based on ID
		 * @param {string} sectionId Id of section/href of anchor without #
		 */
		const isIntersectingCallback = (sectionId) => {
			// Check for a previously highlighted toc item and remove it's highlight
			if ($toc.scrolledToElement && tocMap[$toc.scrolledToElement]) {
				// Since we have a reference in our tocMap we don't need to query
				tocMap[$toc.scrolledToElement].link.classList.remove("menu-active");
			}
			// Highlight the new toc item
			tocMap[sectionId].link.classList.add("menu-active");
			// Add the new item as a property of the toc, so we can unhighlight it later
			$toc.scrolledToElement = sectionId;
		};

		/**
		 * Callback for intersection observer to fire our behavior.
		 * This will fire if something has entered or left our observed area
		 * @param entries {array} Array of IntersectionObserverEntry
		 */

		let previousY = 0;
		let previousRatio = 0;
		let lastSectionId = "";
		let currentSectionId = "";

		const intersectionObserverCallback = (entries) => {
			// Iterate over entries and figure out which one is intersecting
			for (let i = 0; i < entries.length; i++) {
				const sectionId = entries[i].target.id;
				const isIntersecting = entries[i].isIntersecting;

				currentSectionId = sectionId;

				const currentY = entries[i].boundingClientRect.y;
				const currentRatio = entries[i].intersectionRatio;

				// Scrolling down/up
				if (currentY < previousY && currentRatio > previousRatio && isIntersecting) {
					console.log(sectionId + " entered down");
					isIntersectingCallback(sectionId);
					lastSectionId = sectionId;
				}

				if (currentY > previousY && isIntersecting) {
					let keys = Object.keys(tocMap); // Get all keys
					let previousKeyIndex = keys.indexOf(sectionId) - 1; // Find the index of the current key and get the previous index

					if (previousKeyIndex >= 0) {
						let previousKey = keys[previousKeyIndex]; // Get the previous key
						let previousSection = tocMap[previousKey]; // Get the previous section

						isIntersectingCallback(previousSection.id);
					}
				}

				previousY = currentY;
				previousRatio = currentRatio;
			}
		};

		const observer = new IntersectionObserver(intersectionObserverCallback, {
			root: null,
			rootMargin: "-18% 0px -78% 0px",
			threshold: 0,
		});

		// Iterate over anchor links to build our data and fire intersectionObserver
		for (let i = 0; i < $anchorLinks.length; i++) {
			const $anchorLink = $anchorLinks[i];
			// Get the hash, which will be used as a key and a way of selecting the section element
			const hashId = $anchorLink.getAttribute("href").substring(1);
			const $section = document.getElementById(hashId);
			if ($section) {
				// Fill out our data for the sections we care about
				tocMap[hashId] = {
					id: hashId,
					link: $anchorLink,
					section: $section,
				};
				// Kick off intersectionObserver
				observer.observe($section);
			}
		}
	});
</script>

<style>
	.md-content {
		position: relative;
		width: 100%;
	}

	@media screen and (min-width: 1024px) {
		.md-content {
			&.inside {
				display: grid;
				grid-template-columns: calc(100% - 300px - 2rem) min-content;
				grid-template-rows: 1fr;
				gap: 2rem;

				#content {
					grid-row: 1;
					grid-column: 1;
				}

				#toc {
					z-index: 2;
					grid-row: 1;
					grid-column: 2;
					position: sticky;
					top: var(--header-height); /* Navbar */
					height: max-content;
					max-height: calc(100vh - var(--header-height) - 1rem);
					width: 300px;
				}
			}
		}
	}
</style>

<style is:global>
	.md-content {
		img {
			justify-self: center;
			border: 1px solid transparent;
			border-radius: 0.5rem;
		}

		figure:not([class]) {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			figcaption {
				text-align: center;
			}
		}
	}

	nav.toc {
		height: max-content;
		max-height: calc(100vh - var(--header-height) - 5rem);
		scrollbar-width: thin;
		overflow-y: scroll;
		padding-inline: 0.725rem;

		ul {
			margin-top: 0;
			font-size: 0.875rem;
			font-weight: 400;
		}
	}

	#toc {
		summary::marker,
		summary::-webkit-details-marker {
			display: none;
		}

		summary {
			list-style: none;
			pointer-events: none;
		}
	}

	@media screen and (max-width: 1024px) {
		#toc {
			summary::marker,
			summary::-webkit-details-marker {
				display: none;
			}

			details {
				margin-bottom: 1rem;
			}

			summary {
				pointer-events: all;
				padding-left: 1rem;
				margin-bottom: 0;
				position: relative;
				cursor: pointer;
			}
		}
	}
</style>
