---
const { color = "var(--color-primary)", height = "2px", class: className = "loading-indicator", animationDuration = 300 } = Astro.props;

const styles = `.${className} {
  pointer-events: none;
  background-color: ${color};
  position: fixed;
  z-index: 1031;
  top: 0;
  left: 0;
  width: 100%;
  height: ${height};
  transition: transform ${animationDuration}ms ease-out, opacity ${animationDuration / 2}ms ${animationDuration / 2}ms ease-in;
  transform: translate3d(0, 0, 0) scaleX(var(--progress, 0));
  transform-origin: 0;
}`;
---

<style set:html={styles}></style>
<script is:inline define:vars={{ className, animationDuration }}>
	(() => {
		let progress = 0.25;
		let opacity = 0;
		/** @type {number | undefined} */
		let trickleInterval = undefined;
		/** @type {number | undefined} */
		let isTransitioning = false;

		const element = document.createElement("div");
		element.classList.add(className);
		element.ariaHidden = "true";

		/** @param {typeof progress} _progress */
		const setProgress = (_progress) => {
			console.log(_progress);
			progress = _progress;
			element.style.setProperty("--progress", String(progress));
		};
		/** @param {typeof opacity} _opacity */
		const setOpacity = (_opacity) => {
			opacity = _opacity;
			element.style.setProperty("opacity", String(opacity));
		};
		setOpacity(0);

		document.addEventListener("DOMContentLoaded", () => {
			document.body.prepend(element);
			const links = document.querySelectorAll("a");

			links.forEach((link) => {
				link.addEventListener("click", (event) => {
					// Skip if we're already transitioning
					if (isTransitioning) return;

					// Check if it's a same-origin navigation
					if (link.hostname === window.location.hostname) {
						// Prevent default navigation
						event.preventDefault();

						isTransitioning = true;
						setOpacity(1);
						trickleInterval = window.setInterval(() => {
							setProgress(Math.min(progress + Math.random() * 0.03, 0.98));
						}, animationDuration);

						// Perform view transition if supported
						if (document.startViewTransition) {
							const transition = document.startViewTransition(() => {
								// Navigate to the new page
								window.location.href = link.href;
							});

							transition.finished.catch(() => {
								setProgress(1);
								setOpacity(0);
								window.clearInterval(trickleInterval);
								isTransitioning = false;

								// Fallback navigation if transition fails
								window.location.href = link.href;
							});
						} else {
							// Fallback for browsers without View Transitions
							window.location.href = link.href;
						}
					}
				});
			});
		});

		// Handle page events
		window.addEventListener("pagereveal", (e) => {
			if (e.viewTransition) {
				document.body.prepend(element);
				setOpacity(1);
				setProgress(1);
				document.addEventListener("DOMContentLoaded", () => {
					window.setTimeout(() => {
						setProgress(0.25);
					}, animationDuration * 2);

					window.setTimeout(() => {
						setOpacity(0);
					}, animationDuration / 3);
				});
				isTransitioning = false;
			}
		});
	})();
</script>
